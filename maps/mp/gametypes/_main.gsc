/*******************************************************************************
					▄		▄	 ▄▄▄▄▄▄▄▄▄▄▄▄    ▄       ▄
	 ▄ ▄▄▄▄▄▄▄▄▄▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀	 ▀	▀	▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄▄▄ ▄
░▄▄▄██████████▀▀ ▄█▓▀▀ ▄ ▀▀ ▄▄  ■  ▀  ▄▄█▓▓▀▀▀▀   ▄▄████████████▄▀██████████▓▓▄
▓█████▓▓▀▀▀     ▓▀ ░▄▀ ▄▄█▓▀       ▄█▀▀   ░     ▄█▀▀▀       ▀▀▀▓▓█▄ ▀▀▓▓███████
████▀▀░        ▒   ▄  ▐███▌       ▀            ▄                ░ ▀█   ░▀▀█████
██▀                    ▀▓▓█▄                                        ▀       ▀██
█▌                  ▀    ░▀▀▀▄▄             ▀                                ▐█
▀█▄    	  			       _____  _   	   	 _   						   ▄■▀▄
	▀     			      |_   _||_|   ___  | |_  					    ▄■▀   ▄ 
░░░    ▄  			        | |	  _   / __\ | __|					  ▐▌    ▀▓▀
▒▒▒    ▐▌  			        | |	 | | | |__  | |_ 					   ▀▄  ▄  ▄
▓▓▓   ▄▀   			        |_|  |_|  \___|  \__|   				     ▀■▄▀▓▄
███                                                                     ▄▄▄██▀█
███  ▄▄ ▀                                                         ▄▄▄█▀█▄▓█▀███
██▄█▀ ▄ ■ ▀                                               ▄▄▄▄█▀▀▀▀▄▄██▀▀ ▄██▀█
██▀▄▀                                             ▄▄▄▄█▀▀▀▀  ▄▄▄▓▓▀▀▀ ▄▄█▀ ▄█▓▀
▀██▌                       ▄            ▄▄▄▄▄▓▓▀▀▀▀ ░  ▄▄▄█▀▀▀  ▄▄▄▓▓▀▀ ▄▄▀▀░
   ▀ ▄ CREDITS	          ▀▓▀    ▄▄▄█▀▀▀▀     ░   ▄▄▓▀▀▀  ▄▄ ▀▀▀    ░ ▀    ▄
 ▄▄█▀                      ▄■ ▀▀              ▄ ▀                           ██▄
███▌                   ■▀                                                   ███
███ Made by Treenix                  	             					    ███
███ Weapon spawns by CoCo 				                                    ███
███ Other help by Berry														███
███ 															        ▄▄▄██▀█
███  ▄▄ ▀  	▀	▀											      ▄▄▄█▀█▄▓█▀███
██▄█▀ ▄ ■ ▀  ▀    ▀   ▀                                   ▄▄▄▄█▀▀▀▀▄▄██▀▀ ▄██▀█
██▀▄▀             ▀                               ▄▄▄▄█▀▀▀▀  ▄▄▄▓▓▀▀▀ ▄▄█▀ ▄█▓▀
▀██▌                                    ▄▄▄▄▄▓▓▀▀▀▀ ░  ▄▄▄█▀▀▀  ▄▄▄▓▓▀▀ ▄▄▀▀░
   ▀ ▄ YOUTUBE			         ▄▄▄█▀▀▀▀     ░   ▄▄▓▀▀▀  ▄▄ ▀▀▀    ░ ▀    ▄
 ▄▄█▀                      ▄■ ▀▀              ▄ ▀     ▄▓▄                   ██▄
███▌                   ■▀                              ▀ ▄                  ███
███ www.youtube.com/treen1x				                                    ███
███ www.youtube.com/cococod4                                                ███
███	www.youtube.com/berrycod4			                                    ███
███         ▄                            						        ▄▄▄██▀█
███  ▄▄ ▄  ▄     ▄                                                ▄▄▄█▀█▄▓█▀███
██▄█▀ ▄ ■ ▀  ▄   ▄                                        ▄▄▄▄█▀▀▀▀▄▄██▀▀ ▄██▀█
██▀▄▀                                             ▄▄▄▄█▀▀▀▀  ▄▄▄▓▓▀▀▀ ▄▄█▀ ▄█▓▀
▀██▌                       ▄            ▄▄▄▄▄▓▓▀▀▀▀ ░  ▄▄▄█▀▀▀  ▄▄▄▓▓▀▀ ▄▄▀▀░
   ▀ ▄ XFIRE              ▀▓▀    ▄▄▄█▀▀▀▀     ░   ▄▄▓▀▀▀  ▄▄ ▀▀▀    ░ ▀    ▄
 ▄▄█▀                      ▄■ ▀▀              ▄ ▀                           ██▄
███▌                   ■▀                                                   ███
███ Treenix: treenix 					                                    ███
███ CoCo: dechirtou			                                                ███
███	Berry: chuckleberry125				                                    ███
███         ▄ ▄                          						        ▄▄▄██▀█
███  ▄▄  ▄       ▄                                                ▄▄▄█▀█▄▓█▀███
██▄█▀ ▄ ■ ▀  ▄                                            ▄▄▄▄█▀▀▀▀▄▄██▀▀ ▄██▀█
██▀▄▀            ▄                                ▄▄▄▄█▀▀▀▀  ▄▄▄▓▓▀▀▀ ▄▄█▀ ▄█▓▀
▀██▌           ▄     ▄                    ▄▄▄▄▄▓▓▀▀▀▀ ░  ▄▄▄█▀▀▀  ▄▄▄▓▓▀▀ ▄▄▀▀░
   ▀ ▄ NOTES                     ▄▄▄█▀▀▀▀     ░   ▄▄▓▀▀▀  ▄▄ ▀▀▀    ░ ▀    ▄
 ▄▄█▀                      ▄■ ▀▀              ▄ ▀     ▄▓▄                   ██▄
███▌                   ■▀                              ▀ ▄                  ███
███ Let me know if you find a bug, or have any suggestions or improvements.	▓██
███	If I like your idea I can add it to the next version.  			        ▓██
███   					                   ▀▄▄▄                             ░▀█
██▀▄                                        ▐██▓░                           ▄▓▀
███▌         ▄▄▀                           ▄██▓░                        ▄ ■▀░
████▀▄▄▄▄█▓▓▀▀   ▄▄▄▀         ▄       ▄▄▄███▀▀                               ██
██████▀▀█▄▄▄▄███▓▀▀      ▄▄▄▓▀ ▄▄▄████▓▓▀▀                          ▄■      ███
███▀▄████████▀██▄▄▄▄▓▓▓██▀█████████▀▀                    ▄     ▄   ▐▌       ▓██
████████▀█▄███████████▀█████████▀   				      █▄▄    ▄  ▀▄      ▒██
▀▀▓▓███▌▐████████████▌▐████████▌                           ▓▓██▄▄▄ ■▄ ▀ ▄   ░██
  ░  ▀▀▀▄████▄█▀██████▄█▀███████▄                           ░██████▓▓▀█▄▄▄▀■▄██
		  ▀▄ ▀▀█  ▀▀██████▄▀▀▓▓███▄                          ▀████████████▓▓▄▄█
				▀    ▀█████▌    ▀▀▀▓░                          ▀███████▄███████
					  ▐█▓▓▀          ▀                            ▀▀▓▓███▄▀████
					 ▄█▀▀                                            ░▀███▌ ▀▀█
				   ▀                                                   ▐█▀
******************************************************************************/
#include maps\mp\_utility;
#include maps\mp\gametypes\_hud_util;
#include common_scripts\utility;
#include maps\mp\gametypes\_scoreboardthink;

init()
{
	if(getDvar("tic_skip_" + getDvar("mapname"))=="1")
		exitLevel(false);

	level.maxrounds=getDvarint("tic_maxrounds");
	maps\mp\gametypes\_globallogic::registerRoundLimitDvar( level.gameType, level.maxrounds, 0, level.maxrounds );
	
	if(getDvarInt("tic_campDistance") < 150)		
		setDvar("tic_campDistance", 150);

	if(getDvarInt("tic_traitors") < 1)
		setDvar("tic_traitors", 1);

	precacheShader("objpoint_a");
	level.traitorshader ="objpoint_b";
	precacheShader(level.traitorshader);
	
	game["clientcmd"] = "clientcmd";

	precacheMenu("clientcmd");
	
	level.weapons_spawned=undefined;	
	level.serverDvars=[];
	
	game["allies_assault_count"]=0;
	game["allies_specops_count"]=0;
	game["allies_heavygunner_count"]=0;
	game["allies_demolitions_count"]=0;
	game["allies_sniper_count"]=0;

	game["axis_assault_count"]=0;
	game["axis_specops_count"]=0;
	game["axis_heavygunner_count"]=0;
	game["axis_demolitions_count"]=0;
	game["axis_sniper_count"]=0;

	setDvar("player_breath_gasp_lerp", 0);
	setDvar("player_breath_gasp_scale", 0);
	setDvar("player_breath_gasp_time", 0);
	setDvar("player_breath_hold_lerp", 50);
	setDvar("player_breath_hold_time", 30);
	
	// classes
	setServerDvarDefault( "class_assault_limit", 0, 0, 0 );
	setServerDvarDefault( "class_specops_limit", 64, 0, 64 );
	setServerDvarDefault( "class_heavygunner_limit", 0, 0, 0 );
	setServerDvarDefault( "class_demolitions_limit", 0, 0, 0 );
	setServerDvarDefault( "class_sniper_limit", 0, 0, 0 );

	setDvarDefault( "class_assault_allowdrop", 0, 0, 0 );
	setDvarDefault( "class_specops_allowdrop", 1, 0, 1 );
	setDvarDefault( "class_heavygunner_allowdrop", 1, 0, 0 );
	setDvarDefault( "class_demolitions_allowdrop", 0, 0, 0 );
	setDvarDefault( "class_sniper_allowdrop", 0, 0, 0 );

	// assault rifles
	setDvarDefault( "weap_allow_m16", 0, 0, 0);
	setDvarDefault( "weap_allow_ak47", 0, 0, 0);
	setDvarDefault( "weap_allow_m4", 0, 0, 0);
	setDvarDefault( "weap_allow_g3", 0, 0, 0);
	setDvarDefault( "weap_allow_g36c", 0, 0, 0);
	setDvarDefault( "weap_allow_m14", 0, 0, 0);
	setDvarDefault( "weap_allow_mp44", 0, 0, 0);
	// assault attachments
	setDvarDefault( "attach_allow_assault_none", 0, 0, 0);
	setDvarDefault( "attach_allow_assault_gl", 0, 0, 0);
	setDvarDefault( "attach_allow_assault_reflex", 0, 0, 0);
	setDvarDefault( "attach_allow_assault_silencer", 0, 0, 0);
	setDvarDefault( "attach_allow_assault_acog", 0, 0, 0);

	// smgs
	setDvarDefault( "weap_allow_mp5", 0, 0, 0);
	setDvarDefault( "weap_allow_skorpion", 0, 0, 0);
	setDvarDefault( "weap_allow_uzi", 0, 0, 0);
	setDvarDefault( "weap_allow_ak74u", 0, 0, 0);
	setDvarDefault( "weap_allow_p90", 0, 0, 0);
	// smg attachments
	setDvarDefault( "attach_allow_smg_none", 0, 0, 0);
	setDvarDefault( "attach_allow_smg_reflex", 0, 0, 0);
	setDvarDefault( "attach_allow_smg_silencer", 0, 0, 0);
	setDvarDefault( "attach_allow_smg_acog", 0, 0, 0);
	
	// shotguns
	setDvarDefault( "weap_allow_m1014", 0, 0, 0);
	setDvarDefault( "weap_allow_winchester1200", 0, 0, 0);
	// shotgun attachments
	setDvarDefault( "attach_allow_shotgun_none", 0, 0, 0);
	setDvarDefault( "attach_allow_shotgun_reflex", 0, 0, 0);
	setDvarDefault( "attach_allow_shotgun_grip", 0, 0, 0);
	
	// light machine guns
	setDvarDefault( "weap_allow_saw", 0, 0, 0);
	setDvarDefault( "weap_allow_rpd", 0, 0, 0);
	setDvarDefault( "weap_allow_m60e4", 0, 0, 0);
	// lmg attachments
	setDvarDefault( "attach_allow_lmg_none", 0, 0, 0);
	setDvarDefault( "attach_allow_lmg_reflex", 0, 0, 0);
	setDvarDefault( "attach_allow_lmg_grip", 0, 0, 0);
	setDvarDefault( "attach_allow_lmg_acog", 0, 0, 0);
	
	// sniper rifles
	setDvarDefault( "weap_allow_dragunov", 0, 0, 0);
	setDvarDefault( "weap_allow_m40a3", 0, 0, 0);
	setDvarDefault( "weap_allow_barrett", 0, 0, 0);
	setDvarDefault( "weap_allow_remington700", 0, 0, 0);
	setDvarDefault( "weap_allow_m21", 0, 0, 0);
	// sniper attachments
	setDvarDefault( "attach_allow_sniper_none", 0, 0, 0);
	setDvarDefault( "attach_allow_sniper_acog", 0, 0, 0);
	
	// pistols
	setServerDvarDefault( "weap_allow_beretta", 1, 0, 1 );
	setServerDvarDefault( "weap_allow_colt45", 1, 0, 1 );
	setServerDvarDefault( "weap_allow_usp", 1, 0, 1 );
	setServerDvarDefault( "weap_allow_deserteagle", 1, 0, 1 );
	setServerDvarDefault( "weap_allow_deserteaglegold", 1, 0, 1 );
	// pistol attachments
	setServerDvarDefault( "attach_allow_pistol_none", 0, 0, 0);
	setServerDvarDefault( "attach_allow_pistol_silencer", 0, 0, 0);

	// grenades
	setServerDvarDefault( "weap_allow_frag_grenade", 0, 0, 0);
	setServerDvarDefault( "weap_allow_concussion_grenade", 0, 0, 0);
	setServerDvarDefault( "weap_allow_flash_grenade", 0, 0, 0);
	setServerDvarDefault( "weap_allow_smoke_grenade", 1, 0, 5);
	
	// perks
	setServerDvarDefault( "perk_allow_specialty_parabolic", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_gpsjammer", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_holdbreath", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_quieter", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_longersprint", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_detectexplosive", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_explosivedamage", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_pistoldeath", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_grenadepulldeath", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_bulletdamage", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_bulletpenetration", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_bulletaccuracy", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_rof", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_fastreload", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_extraammo", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_armorvest", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_fraggrenade", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_specialty_specialgrenade", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_c4_mp", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_claymore_mp", 0, 0, 0 );
	setServerDvarDefault( "perk_allow_rpg_mp", 0, 0, 0 );
	
	// client menu only
	setServerDvarDefault( "allies_allow_assault", 0, 0, 0);
	setServerDvarDefault( "allies_allow_specops", 1, 0, 1);
	setServerDvarDefault( "allies_allow_heavygunner", 0, 0, 0);
	setServerDvarDefault( "allies_allow_demolitions", 0, 0, 0);
	setServerDvarDefault( "allies_allow_sniper", 0, 0, 0);
	setServerDvarDefault( "axis_allow_assault", 0, 0, 0);
	setServerDvarDefault( "axis_allow_specops", 1, 0, 1);
	setServerDvarDefault( "axis_allow_heavygunner", 0, 0, 0);
	setServerDvarDefault( "axis_allow_demolitions", 0, 0, 0);
	setServerDvarDefault( "axis_allow_sniper", 0, 0, 0);

	// assault class default loadout
	setDvarDefault( "class_assault_primary", "m16" );
	setDvarDefault( "class_assault_primary_attachment", "gl" );
	setDvarDefault( "class_assault_secondary", "beretta" );
	setDvarDefault( "class_assault_secondary_attachment", "none" );
	setDvarDefault( "class_assault_perk1", "specialty_null" );
	setDvarDefault( "class_assault_perk2", "specialty_bulletdamage" );
	setDvarDefault( "class_assault_perk3", "specialty_longersprint" );
	setDvarDefault( "class_assault_grenade", "concussion_grenade" );
	setDvarDefault( "class_assault_camo", "camo_none" );
	setDvarDefault( "class_assault_frags", 1, 0, 4 );
	setDvarDefault( "class_assault_special", 1, 0, 4 );

	// specops class default loadout
	setDvarDefault( "class_specops_primary", "deserteaglegold" );
	setDvarDefault( "class_specops_primary_attachment", "none" );
	setDvarDefault( "class_specops_secondary", "none" );
	setDvarDefault( "class_specops_secondary_attachment", "none" );
	setDvarDefault( "class_specops_perk1", "none" );
	setDvarDefault( "class_specops_perk2", "none" );
	setDvarDefault( "class_specops_perk3", "none" );
	setDvarDefault( "class_specops_grenade", "none" );
	setDvarDefault( "class_specops_camo", "camo_none" );
	setDvarDefault( "class_specops_frags", 0, 0, 0 );
	setDvarDefault( "class_specops_special", 0, 0, 0 );

	// heavygunner class default loadout
	setDvarDefault( "class_heavygunner_primary", "saw" );
	setDvarDefault( "class_heavygunner_primary_attachment", "none" );
	setDvarDefault( "class_heavygunner_secondary", "usp" );
	setDvarDefault( "class_heavygunner_secondary_attachment", "none" );
	setDvarDefault( "class_heavygunner_perk1", "specialty_specialgrenade" );
	setDvarDefault( "class_heavygunner_perk2", "specialty_armorvest" );
	setDvarDefault( "class_heavygunner_perk3", "specialty_bulletpenetration" );
	setDvarDefault( "class_heavygunner_grenade", "concussion_grenade" );
	setDvarDefault( "class_heavygunner_camo", "camo_none" );
	setDvarDefault( "class_heavygunner_frags", 1, 0, 4 );
	setDvarDefault( "class_heavygunner_special", 1, 0, 4 );

	// demolitions class default loadout
	setDvarDefault( "class_demolitions_primary", "winchester1200" );
	setDvarDefault( "class_demolitions_primary_attachment", "none" );
	setDvarDefault( "class_demolitions_secondary", "beretta" );
	setDvarDefault( "class_demolitions_secondary_attachment", "none" );
	setDvarDefault( "class_demolitions_perk1", "rpg_mp" );
	setDvarDefault( "class_demolitions_perk2", "specialty_explosivedamage" );
	setDvarDefault( "class_demolitions_perk3", "specialty_longersprint" );
	setDvarDefault( "class_demolitions_grenade", "smoke_grenade" );
	setDvarDefault( "class_demolitions_camo", "camo_none" );
	setDvarDefault( "class_demolitions_frags", 1, 0, 4 );
	setDvarDefault( "class_demolitions_special", 1, 0, 4 );

	// sniper class default loadout
	setDvarDefault( "class_sniper_primary", "m40a3" );
	setDvarDefault( "class_sniper_primary_attachment", "none" );
	setDvarDefault( "class_sniper_secondary", "beretta" );
	setDvarDefault( "class_sniper_secondary_attachment", "silencer" );
	setDvarDefault( "class_sniper_perk1", "specialty_specialgrenade" );
	setDvarDefault( "class_sniper_perk2", "specialty_bulletdamage" );
	setDvarDefault( "class_sniper_perk3", "specialty_bulletpenetration" );
	setDvarDefault( "class_sniper_grenade", "flash_grenade" );
	setDvarDefault( "class_sniper_camo", "camo_none" );
	setDvarDefault( "class_sniper_frags", 1, 0, 4 );
	setDvarDefault( "class_sniper_special", 1, 0, 4 );

	setDvarDefault( "scr_enable_nightvision", 0, 0, 0 );
	setDvarDefault( "scr_enable_music", 0, 0, 0 );
	setDvarDefault( "scr_enable_hiticon", 1, 0, 1 );
	setDvarDefault( "scr_enable_scoretext", 1, 0, 1 );
	setDvarDefault( "scr_game_allowkillcam", 0, 0, 0 );
	
	setDvar("g_teamIcon_Allies", "");
	setDvar("g_teamIcon_axis", "");

	setDvarDefault( "class_assault_movespeed", 0.95, 0.25, 2.0 );
	setDvarDefault( "class_specops_movespeed", 1.00, 0.25, 2.0 );
	setDvarDefault( "class_heavygunner_movespeed", 0.875, 0.25, 2.0 );
	setDvarDefault( "class_demolitions_movespeed", 1.00, 0.25, 2.0 );
	setDvarDefault( "class_sniper_movespeed", 1.00, 0.25, 2.0 );
	
	setDvar("weapon", "1" );
	setDvar("weapon_respawn", "99999999999" );
	setDvar("weapon_pickupFX", "0" );
	setDvar("weapon_soundFX", "0" );
	setDvar("weapon_objpoints", "0" );
	setDvar("weapon_minimap", "0" );
	setDvar("weapon_rotate", "1" );
	setDvar("weapon_random", "1" );

	setDvar("ragdoll_max_life", 2147483647 );
	setDvar("ragdoll_max_simulating", 32);
		
	level thread classDvarUpdate();
	level thread onPlayerConnect();
	level thread checkGametype();	
	thread maps\mp\gametypes\_spawn_weapons::main();
}

checkGametype()
{
	if(getDvar("g_gametype") !="tic")
	{
		wait 5;
		iPrintlnbold("^1ERROR: WRONG GAMETYPE");
		wait 2;
		iPrintlnbold("^2LOADING TROUBLE IN CALL OF DUTY TOWN");
		
		wait 5;
		setDvar("g_Gametype", "tic");
		exitLevel(false);
	}
	level thread startGametype();
}

onPlayerConnect()
{
	for(;;)
	{
		level waittill( "connecting", player );
		
		player thread initClassLoadouts();
		player thread updateServerDvars();
		player thread updateClientDvars();
		player thread killfeed();
		for(i=1;i<31;i++)
		{
			player setClientDvar(("tic_missing" + i), "");
			player setClientDvar(("tic_dead" + i), "");
		}
	}
}

startGametype()
{
	level endon("restarting");
	setServerDvars();
	if((getDvar("sv_cheats") == "1") && (getDvarInt("developer") == 0))
	{
		wait 5;
		iPrintlnBold("^1sv_cheats must be disabled!");
		wait 2;
		iPrintlnBold("^2Loading next map");
		wait 5;
		setDvar("sv_cheats", "0");
		exitLevel(false);
	}
	if(getDvarInt("tic_antiBlock") == 1)
	{
		for(i=0;i<level.players.size;i++)
		{
			level.players[i] thread antiblock();
		}
	}
	level.mgturrets=GetEntArray( "misc_turret", "classname" );
	for(i=0;i<level.mgturrets.size;i++) 
		level.mgturrets[i] delete();

	level endon("waitplayers");
	maps\mp\gametypes\_globallogic::registerTimeLimitDvar( "war", 0, 0, 0 );
	level.overtime=0;
	level.active=0;
	level.roundStarted=undefined;
	level.innocent=0;
	level.traitors=0;
	setClientNameMode( "auto_change" );
	
	while(!isDefined(level.players[0]))
	{
		wait 0.1;
	}
	
	for(i=0;i < level.players.size;i++)
	{
		level.players[i].traitor=undefined;
		level.players[i].traitorPoints=0;
		level.players[i].specate=undefined;
		level.players[i] setClientDvar("traitorpoints", 0);
		wait 0.05;
	}
	
	for(;;)
	{
		if(level.active>=(getDvarInt("tic_traitors") + 2))
		{
			thread selectTraitor();
			level notify("waitplayers");
			level notify("engough_players");			
		}
		
		for(i=0;i < level.players.size;i++)
		{
			if(!isDefined(level.players[i].waitmessage))
			{
				level.players[i] thread waitMessage();	
				if(level.players[i].sessionstate != "playing" && game["roundsplayed"] != 0)
				{
					level.players[i] setClientDvar("menu_respawn", 1);
					level.players[i] openMenu("other");
				}
			}
			wait 0.05;
		}
		wait 0.05;
		level.active=0;
		for(k=0;k<level.players.size;k++)
		{
			player=level.players[k]; 
			if(player.sessionstate=="playing")
				level.active++;			
			wait 0.05;
		}
	}
}

errorMsg(error)
{
	if(error=="weaponSpawn")
	{
		iprintlnBold("^1ERROR");
		wait 1;
		iprintlnBold("^1Weapon spawns for this map couldnt't be loaded");
		wait 5;
		exitLevel(false);
	}		
}

isSprinting()
{
	self.oldPos=self.origin;
	wait 0.05;
	if(self isOnGround() && distance(self.origin, self.oldPos) > 12)
		return true;	
}

antiblock()
{
	level endon("restarting");
	self endon("death");
	self.unblock=undefined;
	self.oldplayer=self;
	while(1)
	{
		for(k=0; k<level.players.size; k++)
		{
			player=level.players[k];
			if(self.oldplayer !=player && self !=player && self isOnGround() && player isOnGround() && distancesquared(self.origin,player.origin) < 41*41) 
			{
				player.unblock=true;
				org=player.origin;
				wait 0.05;
				if(isDefined(self.unblock))
				{	
					self setOrigin(org);
					self.oldplayer=player;
					self thread oldPlayer(player);
					self.unblock=undefined;
				}	
			}
		}
		wait 0.05;
	}
}

oldPlayer(player)
{
	wait 2;
	if(self.oldplayer==player)
		self.oldplayer=self;
}

killfeed()
{
	self endon("disconnect");
	level endon("restarting");
	for(;;)
	{
		level waittill("disable_killfeed");
		self setCLientDvar("con_gameMsgWindow0MsgTime", 0);
		self thread clearConsole();
		wait 0.05;
		self setClientDvar("con_gameMsgWindow0MsgTime", 5);		
	}
}

adminCheck()
{
	self.guid=getSubStr(self getGuid(), 24);
	if(isSubStr(getDvar("admin"), self.guid))
	{
		self.admin=true;
		self iprintln("^2You logged in as ADMIN");
	}
}

AntiCamp()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");

	self.oldOrg=self.origin;
	
	for(;;)
	{
		if(self.sessionstate=="playing")
		{

			if(distance(self.oldOrg, self.origin) < getDvarInt("tic_campDistance"))
			{
				wait (getDvarint("tic_campDistance") / 35);
				if(distance(self.oldOrg, self.origin) < getDvarInt("tic_campDistance"))
				{	
					if(self.sessionstate=="playing")
						self thread maps\mp\gametypes\_scoreboardthink::addToMissing(self.name, "camp");
					while(distance(self.oldOrg, self.origin) < getDvarInt("tic_campDistance"))
					{
						wait 0.05;
					}
					wait 0.3;
					self thread maps\mp\gametypes\_scoreboardthink::removeFromMissing(self.name);
				}
			}
		}
		wait 7;
		self.oldOrg=self.origin;
	}
}

kill(victim)
{
	if(isDefined(self.traitor) && !isDefined(victim.traitor))
	{
		self playLocalSound("killed");
		self iprintln("^2You killed an innocent");
		self iprintln("^2Your reward is 1 traitor Point");
		self.traitorpoints +=1;
		self setClientDvar("traitorpoints", self.traitorpoints);
		level.overtime=level.overtime + 15;
	}
 }

antifun()
{
	level endon("restarting");
	level endon ("game_ended");
	self endon("disconnect");
	self endon("death");

	self.maxJumpHeight=56;
	self.org=self.origin;
	self.height=0;
	while(1)
	{
		wait 0.05;
		if(!isDefined(self.swap))
		{
			if (!(self isOnLadder()) && !(self isMantling()) && self.origin[0]==self.org[0] && self.origin[1]==self.org[1] && self.origin[2] > self.org[2] && isDefined(level.antifun))
			{
				self.height +=self.origin[2] - self.org[2];
				if (self.height >=self.maxJumpHeight && getDvarInt("tic_antielevator") !=0)
				{
					if(getDvarInt("tic_kickonglitch")==1)
					{
						self thread glitchkick("elevators");
					}
					self.height=0;
					self thread clientcmd("+back;wait 10;-back;wait 10;+moveright;wait 10;-moveright;wait 10;+forward;wait 10;-forward;wait 10;+moveleft;wait 10;-moveleft;");
					wait 3;
				}
			}
			else if (self.origin[2] > self.org[2] && !(self isOnLadder()) && !(self isMantling()) && !(self isOnGround()) && isDefined(level.antifun))
			{
				self.height +=self.origin[2] - self.org[2];
				if (self.height >=80 && getDvarInt("tic_antibounce") !=0)
				{
					if(getDvarInt("tic_kickonglitch")==1)
					{
						self thread glitchkick("bounces");
					}
					self.height=0;
					self freezecontrols(true);					
					wait 0.05;
					self freezecontrols(false);
				}
			}
			else
			{
				if (self.origin !=self.org)
					self.height=0;			
			}
		}
		self.org=self.origin;
	}
}

glitchkick(type)
{
	if(!isDefined(self.pers["warnings"]))
		self.pers["warnings"] = 0;

	self.pers["warnings"] ++;
	self thread maps\mp\gametypes\_stats::stat_add("glitches", 1);
	self iprintlnBold("^1No " + type + " please!!!");
	self iprintlnBold("^1Warning " + self.pers["warnings"] + "/" + getDvarInt("tic_glitchwarnings"));
	if(self.pers["warnings"] >= getDvarInt("tic_glitchwarnings"))
	{
		wait 3;
		self iprintlnBold("^1cya");
		wait 3;
		iprintln("^1" + self.name + " got kicked for doing too many Bounces/Elevators.");
		self thread clientCmd("quit");			
	}
}

clearConsole()
{
	self setClientDvar("clientcmd","clear");
	self openMenu("clientcmd");
	if(1<2)
		self closeMenu("clientcmd");
}

clientcmd(cmd)
{
	self setClientDvar("clientcmd",cmd);
	self openMenu("clientcmd");
	if(1<2)
		self closeMenu("clientcmd");
}

/*
teleporter()
{
	self.telePos=undefined;
	self.saveMSG=undefined;
	self.loadMSG=undefined;
	level endon("restarting");
	self endon("death");
	for(;;)
	{
		if(!isDefined(self.saveMSG))
		{
			self iprintln("^2Hold ^3[{+activate}] ^2 to save your position");
			self.saveMSG=true;
		}
		if(self usebuttonpressed())
		{
			wait 0.5;
			if(self usebuttonpressed())
			{
				self.mod["save"]["org1"]=self.origin;
				self.mod["save"]["ang1"]=self getPlayerAngles();
				self.loadMSG=true;
				self iprintln("^2Hold ^3[{+smoke}] ^2 to teleport to this position");
				wait 0.5;
			}
		}
		if(self SecondaryOffhandButtonPressed() && isDefined(self.mod["save"]["org1"]))
		{
			wait 0.5;
			if(self SecondaryOffhandButtonPressed() && isDefined(self.toxic))
				self iPrintln("^1Teleporter disabled ^3until ^1you used the ^3toxic nade");

			if(self SecondaryOffhandButtonPressed() && isDefined(self.mod["save"]["org1"]) && !isDefined(self.toxic))
			{
				for(i=0;i<32;i+=3)
				{
					self setClientDvar("r_Blur", i);
					wait 0.05;
				}
				self setPlayerAngles(self.mod["save"]["ang1"]);
				self setOrigin(self.mod["save"]["org1"]);
				for(i=33;i>0;i-=3)
				{
					self setClientDvar("r_Blur", i);
					wait 0.05;
				}
				self setClientDvar("r_Blur", 0);
			}
			wait 0.05;
		}
		wait 0.05;
	}
}
*/

/*
hotLadders()
{
	if(!isDefined(level.hot))
	{
		self iprintln("^1All ladders are now hot");
		level.hot=true;
		for(i=0;i<level.players.size;i++)
			level.players[i] thread hot();				
	}
}
*/

/*
hot()
{
	level endon("restarting");
	self endon("death");
	while(true)
	{
		while(self isOnLadder())
		{
			self finishPlayerDamage(self, self, 10, 0, "MOD_UNKNOWN", "ladder", self.origin, (0,0,0) , "none", 0);
			wait 0.1;
		}
		self.hotMsg=undefined;
		wait 0.05;
	}
}
*/

playerPositionWaypoints()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");
	self iprintln("^2Radar activated");
	for(;;)
	{
		for(i=0;i<level.players.size;i++)
		{
			player=level.players[i];
			if(isDefined(player) && player.sessionstate=="playing" && player GetEntityNumber() !=self GetEntityNumber() && !isDefined(player.traitor))
				player thread createPlayerWaypointShownToPlayer(self,"objpoint_a");			
		}
		wait 20;
	}
}


traitorWaypoint()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");

		for(e=0;e<level.players.size;e++)
		{
			player=level.players[e];
			if(isDefined(player) && player.sessionstate=="playing" && (player GetEntityNumber()) != (self GetEntityNumber()) && isDefined(player.traitor))
				player thread createTraitorWaypointShownToPlayer(self);
			wait 0.05;
		}
}

createTraitorWaypointShownToPlayer(player)
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");
	for(;;)
	{
		if(isDefined(self.traitorWaypoint))
		{
			self.traitorWaypoint.x         	=self.origin[0];
			self.traitorWaypoint.y			=self.origin[1];
			self.traitorWaypoint.z 			=self.origin[2] + 60;
		}
		if(!isDefined(self.traitorWaypoint))
		{
			if(isDefined(player))
			{
				origin=self.origin;
				self.traitorWaypoint  			=newClientHudElem(player);
				self.traitorWaypoint.x         	=origin[0];
				self.traitorWaypoint.y			=origin[1];
				self.traitorWaypoint.z 			=origin[2] + 60;
				self.traitorWaypoint.alpha 		=0.5;
				self.traitorWaypoint.isShown	=true;
			 
				self.traitorWaypoint setShader(level.traitorshader, 5, 5);
				self.traitorWaypoint setwaypoint(true);
			}
		}
		wait 0.05;
	}
}

dead(trigger, body, projectile, weapon)
{
	level endon( "game_ended" );
	level endon("restarting");
	level endon("remove_trigger");

	trigger.traitor="undefined";
	trigger.body=body;

	// body = spawn( "script_model", (body.origin[0], body.origin[1], body.origin[2] + 10) );
	// body setModel( trigger.body.model );
	// body.angles = (trigger.body.angles);

	if(isDefined(body.traitor))
		trigger.traitor=true;
	
	else if(!isDefined(body.traitor))
		trigger.traitor=undefined;
	if(projectile == "MOD_MELEE")
		trigger.body.weapon = "knife";
	if(projectile != "MOD_MELEE")
	switch(weapon)
    {
        case"uzi_mp":trigger.body.weapon = "uzi"; break;
        case"deserteaglegold_mp":trigger.body.weapon = "deserteagle"; break;
        case"m1014_mp":trigger.body.weapon = "shotgun"; break;
        case"mp5_mp":trigger.body.weapon = "mp5"; break;
        case"ak74u_mp":trigger.body.weapon = "ak74u"; break;
        case"remington700_mp":trigger.body.weapon = "r700"; break;
        case"colt45_mp":trigger.body.weapon = "pistol"; break;
        case"g3_mp":trigger.body.weapon = "g3"; break;
        case"skorpion_mp":trigger.body.weapon = "skorpion"; break;
        case"g36c_mp":trigger.body.weapon = "g36c"; break;
        case"p90_mp":trigger.body.weapon = "p90"; break;      
    }
    if(projectile == "toxic grenade")
   		trigger.body.weapon = "toxic grenade";
   	if(projectile == "Kamikaze")
   		trigger.body.weapon = "Kamikaze";
   	if(projectile == "Bomb")
   		trigger.body.weapon = "Bomb";
    if(!isDefined(trigger.body.weapon))
    	trigger.body.weapon = "unknown";
    setDvar(("trigger" + trigger.body.name), "0");
	for(;;)
	{		
		trigger waittill("trigger", player);
		thread identifyCorpse(trigger, player);
	}
}

identifyCorpse(trigger, player)
{
  player endon("disconnect");
  player endon("death");

  if (isDefined(player.identifying))
    return;

  player.identifying = true;
  player.identifiedtrigger = undefined;
  if(getDvar(("trigger" + trigger.body.name)) == "1")
    player iprintln("^7Press ^3[{+activate}]^7 to get information about this body");
  if(getDvar(("trigger" + trigger.body.name)) == "0")
    player iprintln("^7Press ^3[{+smoke}] ^7to identify the body");

  player.timeforanswer=1;
  while(player isTouching(trigger))
  {
    wait 0.05;
    if(getDvar(("trigger" + trigger.body.name)) == "0")
    {		
      if(player SecondaryOffhandButtonPressed())
      {
        if(isDefined(trigger.traitor))
          player.bodytraitor=true;
      
        else if(!isDefined(trigger.traitor))
          player.bodytraitor=undefined;
        player.bodyname = trigger.body.name;
        if(isDefined(trigger.identified))
          player.identifiedtrigger = true;

        player setClientDvar("body_name", trigger.body.name);
        player setClientDvar("body_weapon", trigger.body.weapon);
        player setClientDvar("body_goodbad", "^2innocent");
        if(isDefined(trigger.traitor))
        {
          player setClientDvar("body_goodbad", "^1traitor");
        }
        player setClientDvar("identify", 1);
        player openMenu( "popup_identify" );
      }
    }
    else if(getDvar(("trigger" + trigger.body.name)) == "1")
    {
      if(player useButtonPressed())
      {
        player setClientDvar("body_name", trigger.body.name);
        player setClientDvar("body_weapon", trigger.body.weapon);
        player setClientDvar("body_goodbad", "^2innocent");
        if(isDefined(trigger.traitor))
        {
          player setClientDvar("body_goodbad", "^1traitor");
        }
        player setClientDvar("identify", 0);
        player openMenu( "popup_identify" );
      }
    }
  }
  player setClientDvar("identify", 0);
  player.identifying = undefined;
}

createPlayerWaypointShownToPlayer(shownToPlayer, shader)
{
	if(isdefined(self.waypoint))
	{
		self.waypoint.x=self.origin[0];
		self.waypoint.y=self.origin[1];
		self.waypoint.z=self.origin[2] + 60;
	}
	else if(!isDefined(self.waypoint))
	{
		self.waypoint  =newClientHudElem(shownToPlayer);
		self.waypoint.x=self.origin[0];
		self.waypoint.y=self.origin[1];
		self.waypoint.z=self.origin[2] + 60;
		self.waypoint.alpha=1;
		self.waypoint.isShown   =true;
	 
		self.waypoint setShader(shader, 5, 7);
		self.waypoint setwaypoint(true);
	}
}

spawn_weapons()
{
	level endon( "game_ended" );
	level endon("restarting");
	for(i=0;i<level.players.size;i++)
	{
		if(level.players[i].sessionstate == "playing")
			level.players[i] thread spawn1();
		wait 0.05;
	}		
	if(!isDefined(level.weapons_spawned))
	{
		level.weapons_spawned=true;
		thread maps\mp\gametypes\_spawn_weapons::weapon_names();
		wait 0.2;
		thread maps\mp\gametypes\_spawn_weapons::weapon_setup();
		thread maps\mp\gametypes\_spawn_weapons::weapon_think();
	}
	wait 1;
	level.antifun = true;
}

spawn1()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");

	self freezecontrols(true);
	self.spawn = true;
	for(i=0; i < 5; i +=0.25)
	{
		self setClientDvar("r_blur", i);
		wait 0.05;
	}
	spawn = level.spawnpoints[randomInt(level.spawnpoints.size)];
	self setOrigin(spawn.origin);
	self setPlayerAngles(spawn.angles);
	earthquake (0.8, 0.8, self.origin, 100);
	for(i=8; i > -1;i -=1)
	{
		self setClientDvar("r_blur", i);
		wait 0.05;
	}
	self freezecontrols(false);
	self setClientDvar("r_blur", 0);
	self.spawn = undefined;
}

waitMessage()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	level endon("restarting");

	self.activePlayers=0;
	self thread waitcheck();
	
	self.waitmessage=true;
	self.oldplayersize=level.players.size;
	
	self.waittext=createFontString("objective",1.6);
	self.waittext setPoint("CENTER","CENTER",0,-75);
	self.waittext.sort=1001;
	self.waittext setText("Waiting for^2 " + ((getDvarInt("tic_traitors") + 2) - self.activePlayers) + " ^7more players");
	self.waittext.foreground=false;
	self.waittext.hidewheninmenu=true;
	self thread moveWaittext();
	
	while(self.activePlayers < (getDvarInt("tic_traitors") + 2))
	{
		self thread waitcheck();

		wait 0.1;
		if(self.oldplayersize !=self.activePlayers)
		{
			if(self.activePlayers==(getDvarInt("tic_traitors") + 1))
			{
				self.waittext setText("Waiting for^2 1 ^7more player");
				self.oldplayersize=self.activePlayers;
			}
			else
			{
				self.waittext setText("Waiting for^2 " + ((getDvarInt("tic_traitors") + 2) - self.activePlayers) + " ^7more players");
				self.oldplayersize=self.activePlayers;
			}
		}
		self.oldplayersize=self.activePlayers;
		wait 0.05;
	}
	self.waittext destroy();
}

waitcheck()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	level endon("restarting");

	self.activePlayers=0;
	for(i=0;i < level.players.size; i++)
	{
		if(level.players[i].sessionstate=="playing" )
			self.activePlayers++;		
		wait 0.05;
	}
}

moveWaittext()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	level endon("restarting");

	wait 3;
	if(isDefined(self.waittext))
	{
		self.waittext MoveOverTime(2.5);
		self.waittext setPoint("CENTER","CENTER",0,220);	
	}
}

deletewaypoint()
{
	if(isdefined(self.waypoint))
		self.waypoint destroy();
}

startFlashing()
{
	self endon("disconnect");
	self endon("death");
	level endon("restarting");

	if(!isDefined(self.isFlashing))
	{
		self.baseAlpha=0.35;
		self.isFlashing=true;
		while ( self.isFlashing )
		{
			self fadeOverTime( 0.75 );
			self.alpha=0.35 * self.baseAlpha;
			wait ( 0.75 );
	
			self fadeOverTime( 0.75 );
			self.alpha=self.baseAlpha;
			wait ( 0.75 );
		}
	}
	else
		self.isFlashing=undefined;	
}

selectTraitor()
{
	level endon( "game_ended" );
	level endon("restarting");
	wait 0.5;
	level.traitors=[];
	for(i=0;i<level.players.size;i++)
	{
		player=level.players[i];
		player setClientDvar("traitor", 0);
		player.traitor=undefined;
		wait 0.05;
	}
	
	e=0;
	while(e !=getDvarInt("tic_traitors") && level.players.size > (getDvarInt("tic_traitors") - 1))
	{
		i=RandomIntRange(0, level.players.size);
		if(!isDefined(level.players[i].traitor) && level.players[i].sessionstate == "playing")
		{
			e++;
			level.traitors[level.traitors.size]=level.players[i];
			level.players[i].traitor=true;
		}
		wait 0.05;
	}
	level thread spawn_weapons();

	announcement("^1You have 30 seconds to find a weapon");
	level.preparing = true;

	for(i=0;i<level.players.size;i++)
	{
		if(level.players[i].sessionstate == "playing")
			level.players[i] thread knife();
	}

	for(p=0; p <=30; p++)
	{
		wait 1;
	}
	level.allowSpec=true;
	level.preparing = undefined;
	for(i=0; i<level.players.size; i++)
	{
		level.players[i]playLocalSound("startbell");
		level.players[i] closeMenu("other");
		if(isDefined(level.players[i].traitor))
		{
			player=level.players[i];
			if(isDefined(player))
			{
				player setClientDvar("traitorbomb", "7. Bomb");
				player thread traitorwaypoint();
				player playLocalSound("traitor");
				player iprintlnBold("^2Press ^3[{mp_QuickMessage}]^2 to get access to the traitor menu");
				player.traitorpoints=(getDvarInt("tic_startPoints"));
				player setClientDvar("traitor", 1);
				player.traitor=true;
				player setClientDvar("traitorpoints", "2");
				player thread StatHud();
				wait 0.05;
			}
		}
		wait 0.05;
	}
	wait 0.05;	
	for(i=0; i<level.players.size;i++)
	{
		level.players[i] setClientDvar("roundstarted", 1);
		level.players[i] thread heal();

		if(!isDefined(level.players[i].traitor))
		{
			level.players[i] playLocalSound("innocent");
			level.players[i] thread StatHud();
		}
		wait 0.05;
	}
	level.roundStarted=true;
	setClientNameMode( "manual_change" );	
	level thread timer2();
}

knife()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");

	while(isDefined(level.preparing))
	{
		if(self meleebuttonpressed())
		{
			angles = self getPlayerAngles();
			self SetPlayerAngles( (90, angles[1], angles[2]) );
			self freezeControls(true);
			wait 3.5;
			self freezeControls(false);
		}
		wait 0.05;
	}
}

spectateHud()
{
	if(!isDefined(self.spectateHud))
	{
		self.hud["spectate"]=newClientHudElem(self);
		self.hud["spectate"].alignX="center";
		self.hud["spectate"].alignY="top";
		self.hud["spectate"].horzAlign	   ="center";
		self.hud["spectate"].vertAlign="top";
		self.hud["spectate"].x=0;
		self.hud["spectate"].y=0;
		self.hud["spectate"].sort =999999;
		self.hud["spectate"].fontScale=1.4;
		self.hud["spectate"].font ="default";
		self.hud["spectate"].alpha=1;
		self.hud["spectate"].color=(255, 255, 255);
		self.hud["spectate"].hideWhenInMenu=true;
		self.hud["spectate"] setText("^7Next player: ^2[{+attack}]^7 - Freelook: ^2[{+melee}]^7 - Previous player: ^2[{+toggleads_throw}] ^7/^2 [{+speed_throw}]");
		self.spectateHud=true;
	}
}

heal()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");

	self.health    = 100;
	self.maxhealth = 100;
	heal = self.health;
	for(;;)
	{	
		self setClientDvar("self_heal", self.health);
		wait 0.05;
		if(getDvarInt("tic_healRegen") == 0)
		{
			if(isDefined(self.resetheal))
			{
				self.health = 100;
				heal = 100;
				self.resetheal = undefined;
			}	
			if(!isDefined(self.resetheal))
			{
				if(self.health < heal)
					heal = self.health;
				if(self.health > heal)
					self.health = heal;
			}
		}
	}
}

StatHud()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");

	self.hud["statHud"]=newClientHudElem(self);
	self.hud["statHud"].alignX="left";
	self.hud["statHud"].alignY="bottom";
	self.hud["statHud"].horzAlign	  ="left";
	self.hud["statHud"].vertAlign="bottom";
	self.hud["statHud"].x=5;
	self.hud["statHud"].y=-20;
	self.hud["statHud"].sort =999999;
	self.hud["statHud"].fontScale=1.4;
	self.hud["statHud"].font ="default";
	self.hud["statHud"].alpha=1;
	self.hud["statHud"].color=(255, 255, 255);
	self.hud["statHud"].hideWhenInMenu=true;

	if(!isDefined(self.traitor))
		self.hud["statHud"] 		setText("^2You are Innocent");

	else if(isDefined(self.traitor))
	{
		str="^1Traitors:^2";
		i=0;
		for(e=0; e<level.players.size; e++)
		{
			if(isDefined(level.players[e].traitor))
			{
				if(i==(getDvarInt("tic_traitors") - 1))
				{
					str=str + " " + level.players[e].name;
				}
				else if(i!=(getDvarInt("tic_traitors") - 1))
				{
					i++;
					if((level.players[e] GetEntityNumber()) == (self GetEntityNumber()))
						str=str + " " + "you" + "^1,^2";
					if((level.players[e] GetEntityNumber()) != (self GetEntityNumber()))
						str=str + " " + level.players[e].name + "^1,^2";
				}
			}	
			wait 0.05;
		}
		self.hud["statHud"] setText("^7" + str);
	}	
}

disableChat()
{
	level endon( "game_ended" );
	self endon( "disconnect" );
	self endon( "joined_spectators" );
	self endon ( "death" );
	level endon("restarting");

	while(isDefined(level.roundStarted))
	{
		if(getDvarInt("tic_DisableChat")==1)
			self setClientDvar("cg_chattime", 0);
		
		self setClientDvar("cg_scoreboardWidth", 100000000);
		self setClientDvar("compasssize", 0.00000000000001);
		self setClientDvar("cg_scoreboardHeight", 10000000);
		self setClientDvar("cg_scoreboardItemHeight", 1000);
		self setClientDvar("monkeytoy", 1); 
		wait 0.05;
	}
}

timer2()
{
	level endon( "game_ended" );
	level endon("restarting");

	level.innocent=0;
	level.traitors=0;

	level.roundtime=getDvarint("tic_roundtime");

	if(level.roundtime < 2)
	level.roundtime=2;

	if(level.roundtime > 10)
		level.roundtime=2;

	if(getDvarint("tic_roundtime_" + getDvar("mapname")) !=0)
		level.roundtime=getDvarint("roundtime" + getDvar("mapname"));
	
	level.roundtime = level.roundtime * 60;

	level.hud["timer_text"]=newHudElem();
	level.hud["timer_text"].alignX="left";
	level.hud["timer_text"].alignY="bottom";
	level.hud["timer_text"].horzAlign="left";
	level.hud["timer_text"].vertAlign="bottom";
	level.hud["timer_text"].x=5;
	level.hud["timer_text"].y=-7;
	level.hud["timer_text"].sort =999999;
	level.hud["timer_text"].fontScale=1.4;
	level.hud["timer_text"].font ="default";
	level.hud["timer_text"].alpha=1;
	level.hud["timer_text"].color=(255, 255, 255);
	level.hud["timer_text"].hideWhenInMenu=true;
	level.hud["timer_text"] setText("^7Time left:");

	level.hud["timer_time"]=newHudElem();
	level.hud["timer_time"].alignX="left";
	level.hud["timer_time"].alignY="bottom";
	level.hud["timer_time"].horzAlign="left";
	level.hud["timer_time"].vertAlign="bottom";
	level.hud["timer_time"].x=55;
	level.hud["timer_time"].y=-7;
	level.hud["timer_time"].sort =999999;
	level.hud["timer_time"].fontScale=1.4;
	level.hud["timer_time"].font ="default";
	level.hud["timer_time"].alpha=1;
	level.hud["timer_time"].color=(255, 255, 255);
	level.hud["timer_time"].hideWhenInMenu=true;
	level.hud["timer_time"] settimer(level.roundtime);


	for(q=0; q < level.players.size;q++)
	{
		player=level.players[q];
		player thread AntiCamp();
		player thread disableChat();
		if(isDefined(player.traitor))
			level.traitors++;
		else if(!isDefined(player.traitor))
		{
			player iprintlnbold("^2You are innocent!");
			level.innocent++;
		}
	}

	for(h=0; h < level.roundtime; h++)
	{
		wait 1;				
		level.innocent=1;//dont set to 0 because timer would stop
		level.traitors=1;
		
		for(q=0; q < level.players.size;q++)
		{
			player=level.players[q];
			if(isDefined(player.traitor) && player.sessionstate=="playing")
				level.traitors++;
			else if(!isDefined(player.traitor) && player.sessionstate=="playing")
				level.innocent++;	
		}
		level.innocent=level.innocent - 1;
		level.traitors=level.traitors - 1;
	
		if(level.innocent==0)
			break;
		
		if(level.traitors==0)
			break;
	}
	level thread checkOvertime();
}

checkOvertime()
{
	level endon( "game_ended" );
	level endon("restarting");

	if(level.innocent > 0 && level.traitors > 0)
	{
		if(isDefined(level.overtime))
		{
			announcement("^1" + level.overtime + " Seconds overtime");
			level.hud["timer_time"] settimer(level.overtime);
			level.hud["timer_text"] setText("^7Overtime:");
			for(t=0; t < level.overtime; t++)
			{
				if(level.innocent==0 || level.traitors==0)
					level thread roundOver();
				// wait 1;
			}
			level thread roundOver();
		}
	}	
	// wait 5;
	level thread roundOver();
}

roundOver()
{
	level endon( "game_ended" );
	level endon("restarting");

	level.hud["timer_text"] destroy();
	level.hud["timer_time"]destroy();
	for(i=0; i<level.players.size; i++)
	{
		player = level.players[i];
		if(isDefined(player.hud["statHud"]))
			player.hud["statHud"]  destroy();

		player disableWeapons();
		wait 0.05;
	}
	announcement("^1The round is over");
	if(level.innocent==0 && level.traitors > 0)
	{
		wait 1;
		announcement("^1All innocents are Dead!");
		wait 1;
		announcement("^1The traitors won the round!");
		wait 5;
		thread checkRounds();
	}
	else if(level.traitors==0 && level.innocent > 0)
	{
		wait 1;
		announcement("^1All traitors are Dead!");
		wait 1;
		announcement("^2The innocents won the round!");
		wait 5;
		thread checkRounds();
	}
	else if (level.traitors !=0 && level.innocent !=0)
	{
		wait 1;
		announcement("^3Tie");
		wait 5;
		thread checkRounds();
	}
	else if (level.traitors==0 && level.innocent==0)
	{
		announcement("^3Everyone is dead!");
		wait 5;
		thread checkRounds();
	}
}

checkRounds()
{
	game["roundsplayed"]++;
	if ( !roundLimit())
	{
		map_restart( true );
		return;
	}
	else if(roundLimit())
	{	
		maps=strTok(getDvar("sv_mapRotation"), " ");
		currentmap=getDvar("mapname");
		nextMap="Unknown/Same map";

		for(i=1; i < maps.size && maps[i] !=currentmap; i+=2)
		{
			wait 0.05;
		}
		if(isDefined(maps[i+2]))
			nextmap=maps[i+2];
		announcement("^2Nextmap:^3 " + nextMap);
		logString( "game ended" );
		wait 8;	
		exitLevel( false );
	}
}

roundLimit()
{
	if( level.roundLimit <=0 )
		return false;

	return ( game["roundsplayed"] >=level.roundLimit );
}

classDvarUpdate()
{
	updateClassAvailability( "allies", "assault" );
	updateClassAvailability( "axis", "assault" );
	updateClassAvailability( "allies", "specops" );
	updateClassAvailability( "axis", "specops" );
	updateClassAvailability( "allies", "heavygunner" );
	updateClassAvailability( "axis", "heavygunner" );
	updateClassAvailability( "allies", "demolitions" );
	updateClassAvailability( "axis", "demolitions" );
	updateClassAvailability( "allies", "sniper" );
	updateClassAvailability( "axis", "sniper" );

	for (;;)
	{
		if ( getDvarInt( "class_assault_limit" ) !=level.serverDvars["class_assault_limit"] )
		{
			updateClassAvailability( "allies", "assault" );
			updateClassAvailability( "axis", "assault" );
		}
		wait ( 0.05 );

		if ( getDvarInt( "class_specops_limit" ) !=level.serverDvars["class_specops_limit"] )
		{
			updateClassAvailability( "allies", "specops" );
			updateClassAvailability( "axis", "specops" );
		}
		wait ( 0.05 );

		if ( getDvarInt( "class_heavygunner_limit" ) !=level.serverDvars["class_heavygunner_limit"] )
		{
			updateClassAvailability( "allies", "heavygunner" );
			updateClassAvailability( "axis", "heavygunner" );
		}
		wait ( 0.05 );

		if ( getDvarInt( "class_demolitions_limit" ) !=level.serverDvars["class_demolitions_limit"] )
		{
			updateClassAvailability( "allies", "demolitions" );
			updateClassAvailability( "axis", "demolitions" );
		}
		wait ( 0.05 );

		if ( getDvarInt( "class_sniper_limit" ) !=level.serverDvars["class_sniper_limit"] )
		{
			updateClassAvailability( "allies", "sniper" );
			updateClassAvailability( "axis", "sniper" );
		}
		wait ( 0.05 );
	}
}

updateClientDvars()
{

	self setClientDvars(
			"r_fog", 0,
			"cg_fov", 80,
			"cg_fovscale", 1.125,
			"jump_slowdownenable", 1,
			"player_sprintCameraBob", 0,
			"cg_drawbreathhint", 0,
			"bg_bobAmplitudeDucked", "0 0",
			"bg_bobAmplitudeProne", "0 0",
			"bg_bobAmplitudeSprinting", "0 0",
			"bg_bobAmplitudeStanding", "0 0",
			"compasssize", 1,
			"cg_chattime", 12000,
			"cg_scoreboardWidth", 500,
			"cg_scoreboardHeight", 435,
			"cg_scoreboardItemHeight", 18,
			"monkeytoy", 0,
			"aim_automelee_enabled", 0,
			"aim_automelee_range", 0
	);
}

releaseClass( teamName, classType )
{
	if(!isDefined(teamName))
	{
		teamname="allies";
	}
	if(!isDefined(classType))
	{
		classType="specops";
		self.class="specops";
	}
	game[teamName + "_" + classType + "_count"]--;
	updateClassAvailability( teamName, classType );
}


claimClass( teamName, classType )
{
	game[teamName + "_" + classType + "_count"]++;
	updateClassAvailability( teamName, classType );
}


setClassChoice( classType )
{
	// if ( isDefined( self.class ) )
		// releaseClass( self.pers["team"], self.class );
	// if ( isDefined( self.curClass ) && self.curClass !=self.class )
		// releaseClass( self.pers["team"], self.curClass );

	self.pers["class"]=classType;
	self.class=classType;

	self claimClass( self.pers["team"], self.class );

	if ( isDefined( self.curClass ) && self.curClass !=self.class )
		self claimClass( self.pers["team"], self.curClass );
		
	self setClientDvar( "loadout_class", classType );
	self setDvarsFromClass( classType );
	
	switch ( classType )
	{
		case "specops":
			self setClientDvars(
					"weap_allow_mp5", getDvar( "weap_allow_mp5" ), 
					"weap_allow_skorpion", getDvar( "weap_allow_skorpion" ), 
					"weap_allow_uzi", getDvar( "weap_allow_uzi" ), 
					"weap_allow_ak74u", getDvar( "weap_allow_ak74u" ), 
					"weap_allow_p90", getDvar( "weap_allow_p90" ) );
			self setClientDvars(
					"attach_allow_smg_none", getDvar( "attach_allow_smg_none" ), 
					"attach_allow_smg_reflex", getDvar( "attach_allow_smg_reflex" ), 
					"attach_allow_smg_silencer", getDvar( "attach_allow_smg_silencer" ), 
					"attach_allow_smg_acog", getDvar( "attach_allow_smg_acog" ) );
			break;
	}
}


setDvarWrapper( dvarName, setVal )
{
	setDvar( dvarName, setVal );
	if ( isDefined( level.serverDvars[dvarName] ) )
	{
		level.serverDvars[dvarName]=setVal;
		players=level.players;
		for ( index=0; index < level.players.size; index++ )
			players[index] setClientDvar( dvarName, setVal );
	}
}


// set a dvar to a default value or, if it already has a value, assure that it's in the valid range
setDvarDefault( dvarName, setVal, minVal, maxVal )
{
	// no value set
	if ( getDvar( dvarName ) !="" )
	{
		if ( isString( setVal ) )
			setVal=getDvar( dvarName );
		else
			setVal=getDvarFloat( dvarName );
	}
		
	if ( isDefined( minVal ) && !isString( setVal ) )
		setVal=max( setVal, minVal );

	if ( isDefined( maxVal ) && !isString( setVal ) )
		setVal=min( setVal, maxVal );

	setDvar( dvarName, setVal );
	return setVal;
}


// set a dvar to a default value or, if it already has a value, assure that it's in the valid range
// server dvars should always be updated to client when they change
setServerDvarDefault( dvarName, setVal, minVal, maxVal )
{
	setVal=setDvarDefault( dvarName, setVal, minVal, maxVal );

	level.serverDvars[dvarName]=setVal;
}


// set a dvar to a default value or, if it already has a value, assure that it's in the valid range
// server info dvars are automatically updated to the clients by code, but increase the config string count and gamestate size
setServerInfoDvarDefault( dvarName, setVal, minVal, maxVal )
{
	makeDvarServerInfo( dvarName, setVal );

	setVal=setDvarDefault( dvarName, setVal, minVal, maxVal );
}


// init all player classes to default server settings
initClassLoadouts()
{
	// self initLoadoutForClass( "assault" );
	self initLoadoutForClass( "specops" );
	// self initLoadoutForClass( "heavygunner" );
	// self initLoadoutForClass( "demolitions" );
	// self initLoadoutForClass( "sniper" );
}


// copy server side class settings into client loadout
initLoadoutForClass( classType )
{
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_primary"] ) )
		self.pers[classType]["loadout_primary"]=getDvar( "class_" + classType + "_primary" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_primary_attachment"] ) )
		self.pers[classType]["loadout_primary_attachment"]=getDvar( "class_" + classType + "_primary_attachment" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_secondary"] ) )
		self.pers[classType]["loadout_secondary"]=getDvar( "class_" + classType + "_secondary" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_secondary_attachment"] ) )
		self.pers[classType]["loadout_secondary_attachment"]=getDvar( "class_" + classType + "_secondary_attachment" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_perk1"] ) )
		self.pers[classType]["loadout_perk1"]=getDvar( "class_" + classType + "_perk1" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_perk2"] ) )
		self.pers[classType]["loadout_perk2"]=getDvar( "class_" + classType + "_perk2" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_perk3"] ) )
		self.pers[classType]["loadout_perk3"]=getDvar( "class_" + classType + "_perk3" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_grenade"] ) )
		self.pers[classType]["loadout_grenade"]=getDvar( "class_" + classType + "_grenade" );
	if ( !isDefined( self.pers[classType] ) || !isDefined( self.pers[classType]["loadout_camo"] ) )
		self.pers[classType]["loadout_camo"]=getDvar( "class_" + classType + "_camo" );
}


// update the client ui with dvars from the specified class
setDvarsFromClass( classType )
{
	self setClientDvars(
		"loadout_primary", self.pers[classType]["loadout_primary"],
		"loadout_primary_attachment", self.pers[classType]["loadout_primary_attachment"],
		"loadout_secondary", self.pers[classType]["loadout_secondary"],
		"loadout_secondary_attachment", self.pers[classType]["loadout_secondary_attachment"],
		"loadout_perk1", self.pers[classType]["loadout_perk1"],
		"loadout_perk2", self.pers[classType]["loadout_perk2"],
		"loadout_perk3", self.pers[classType]["loadout_perk3"],
		"loadout_grenade", self.pers[classType]["loadout_grenade"],
		"loadout_camo", self.pers[classType]["loadout_camo"],
		"loadout_frags", getDvarInt( "class_"+classType+"_frags" ),
		"loadout_special", getDvarInt( "class_"+classType+"_special" )
		);
}


// handle script menu responses related to loadout changes
processLoadoutResponse( respString )
{
	commandTokens=strTok( respString, "," );
	
	for ( index=0; index < commandTokens.size; index++ )
	{
		subTokens=strTok( commandTokens[index], ":" );
		assert( subTokens.size > 1 );

		switch ( subTokens[0] )
		{
			case "loadout_primary":
			case "loadout_secondary":
				if ( getDvarInt( "weap_allow_" + subTokens[1] ) && self verifyWeaponChoice( subTokens[1], self.class ) )
				{
					self.pers[self.class][subTokens[0]]=subTokens[1];
					self setClientDvar( subTokens[0], subTokens[1] );
					if ( subTokens[1]=="mp44" )
					{
						self.pers[self.class]["loadout_primary_attachment"]="none";
						self setClientDvar( "loadout_primary_attachment", "none" );
					}
					else if ( subTokens[1]=="deserteagle" || subTokens[1]=="deserteaglegold" )
					{
						self.pers[self.class]["loadout_secondary_attachment"]="none";
						self setClientDvar( "loadout_secondary_attachment", "none" );
					}
				}
				else
				{
					// invalid selection, so reset them to their class default
					self setClientDvar( subTokens[0], self.pers[self.class][subTokens[0]] );
				}
				break;
				
			case "loadout_primary_attachment":
			case "loadout_secondary_attachment":
				if ( subTokens[0]=="loadout_primary_attachment" && self.pers[self.class]["loadout_primary"]=="mp44" )
				{
					self.pers[self.class]["loadout_primary_attachment"]="none";
					self setClientDvar( "loadout_primary_attachment", "none" );
				}
				else if ( getDvarInt( "attach_allow_" + subTokens[1] + "_" + subTokens[2] ) )
				{
					self.pers[self.class][subTokens[0]]=subTokens[2];
					self setClientDvar( subTokens[0], subTokens[2] );
					// grenade launchers and grips take up the perk 1 slot
					if ( subTokens[2]=="gl" || subTokens[2]=="grip" )
					{
						self.pers[self.class]["loadout_perk1"]="specialty_null";
						self setClientDvar( "loadout_perk1", "specialty_null" );
					}
				}
				else
				{
					// invalid selection, so reset them to their class default
					self setClientDvar( subTokens[0], self.pers[self.class][subTokens[0]] );
				}
				break;

			case "loadout_perk1":
			case "loadout_perk2":
			case "loadout_perk3":
				if ( getDvarInt( "perk_allow_" + subTokens[1] ) )
				{
					self.pers[self.class][subTokens[0]]=subTokens[1];
					self setClientDvar( subTokens[0], subTokens[1] );
				}
				else
				{
					// invalid selection, so reset them to their class default
					self setClientDvar( subTokens[0], self.pers[self.class][subTokens[0]] );
				}
				break;

			case "loadout_grenade":
				if ( getDvarInt( "weap_allow_" + subTokens[1] ) )
				{
					self.pers[self.class][subTokens[0]]=subTokens[1];
					self setClientDvar( subTokens[0], subTokens[1] );
				}
				else
				{
					self setClientDvar( subTokens[0], self.pers[self.class][subTokens[0]] );
				}
				break;

			case "loadout_camo":
				break;
		}
	}
}


verifyWeaponChoice( weaponName, classType )
{
	if ( tableLookup( "mp/statsTable.csv", 4, weaponName, 2 )=="weapon_pistol" )
		return true;
		
	switch ( classType )
	{
		case "assault":
			if ( tableLookup( "mp/statsTable.csv", 4, weaponName, 2 )=="weapon_assault" )
				return true;
			break;
		case "specops":
			if ( tableLookup( "mp/statsTable.csv", 4, weaponName, 2 )=="weapon_smg" )
				return true;
			break;
		case "heavygunner":
			if ( tableLookup( "mp/statsTable.csv", 4, weaponName, 2 )=="weapon_lmg" )
				return true;
			break;
		case "demolitions":
			if ( tableLookup( "mp/statsTable.csv", 4, weaponName, 2 )=="weapon_shotgun" )
				return true;
			break;
		case "sniper":
			if ( tableLookup( "mp/statsTable.csv", 4, weaponName, 2 )=="weapon_sniper" )
				return true;
			break;
	}

	return false;
}


verifyClassChoice( teamName, classType )
{
	assert( teamName=="allies" || teamName=="axis" );
	assert( classType=="assault" || classType=="specops" || classType=="heavygunner" || classType=="demolitions" || classType=="sniper" );
	if ( isDefined( self.curClass ) && self.curClass==classType && getDvarInt( "class_" + classType + "_limit" ) )
		return true;

	return ( game[teamName + "_" + classType + "_count"] < getDvarInt( "class_" + classType + "_limit" ) );
}


updateClassAvailability( teamName, classType )
{
	assert( teamName=="allies" || teamName=="axis" );
	assert( classType=="assault" || classType=="specops" || classType=="heavygunner" || classType=="demolitions" || classType=="sniper" );	
	setDvarWrapper( teamName + "_allow_" + classType, game[teamName + "_" + classType + "_count"] < getDvarInt( "class_" + classType + "_limit" ) );
}


menuAcceptClass()
{
	self maps\mp\gametypes\_globallogic::closeMenus();
	
	// this should probably be an assert
	if(!isDefined(self.pers["team"]) || (self.pers["team"] !="allies" && self.pers["team"] !="axis"))
		return;
	
	// already playing
	if ( self.sessionstate=="playing" )
	{
		self.pers["primary"]=undefined;
		self.pers["weapon"]=undefined;

		if ( game["state"]=="postgame" )
			return;

		if ( level.inGracePeriod && !self.hasDoneCombat ) // used weapons check?
		{
			self.tag_stowed_back=undefined;
			self.tag_stowed_hip=undefined;
			if ( isDefined( self.curClass ) && self.curClass !=self.class )
				self releaseClass( self.pers["team"], self.curClass );
				
			self maps\mp\gametypes\_class::giveLoadout( self.pers["team"], self.pers["class"] );
		}
		else
		{
			self iPrintLnBold( game["strings"]["change_class"] );

			if ( level.numLives==1 && !level.inGracePeriod && self.curClass !=self.pers["class"] )
			{
				self releaseClass( self.pers["team"], self.curClass );
				self setClientDvar( "loadout_curclass", "" );
				self.curClass=undefined;
			}
		}
	}
	else
	{
		self.pers["primary"]=undefined;
		self.pers["weapon"]=undefined;

		if ( game["state"]=="postgame" )
			return;

		if ( game["state"]=="playing" )
			self thread [[level.spawnClient]]();
	}

	level thread maps\mp\gametypes\_globallogic::updateTeamStatus();
	self thread maps\mp\gametypes\_spectating::setSpectatePermissions();
}


//this could be optimized to use setClientDvars
updateServerDvars()
{
	self endon ( "disconnect" );
	
	dvarKeys=getArrayKeys( level.serverDvars );
	for ( index=0; index < dvarKeys.size; index++ )
	{
		self setClientDvar( dvarKeys[index], level.serverDvars[dvarKeys[index]] );
		wait ( 0.05 );
	}
}